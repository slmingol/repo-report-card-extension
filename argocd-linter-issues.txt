ArgoCD Application Linter - Issues Identified
=============================================
Repository: https://github.com/Bandwidth/bw-devops-github-actions/tree/main/argocdApplicationLinter
Date: February 26, 2026

CRITICAL ISSUES:
================

1. INVERTED LOGIC IN ENVIRONMENT DETECTION (Lines 462-467)
-----------------------------------------------------------
Location: main.go, lines 462-467

Current Code:
    env := ""
    if getEnv(appYaml.Spec.Destination.Name) == "" {
        env = getEnv(appYaml.Spec.Destination.Name)
    } else if getEnv(appYaml.Spec.Destination.Server) == "" {
        env = getEnv(appYaml.Spec.Destination.Server)
    } else {
        log.Print("Error getting cluster env")
        os.Exit(1)
    }

Problem: The logic is completely inverted! It assigns env when getEnv() returns 
an empty string, but empty string means the function couldn't determine the 
environment. This will cause the linter to fail for valid configurations or 
incorrectly validate invalid ones.

Fix: Change == "" to != ""
    env := ""
    if getEnv(appYaml.Spec.Destination.Name) != "" {
        env = getEnv(appYaml.Spec.Destination.Name)
    } else if getEnv(appYaml.Spec.Destination.Server) != "" {
        env = getEnv(appYaml.Spec.Destination.Server)
    } else {
        log.Print("Error getting cluster env")
        os.Exit(1)
    }


2. MISSING SERVER VALIDATION IN validateDestinationAllowed() (Lines 251-268)
-----------------------------------------------------------------------------
Location: main.go, lines 251-268

Current Code:
    func (a applicationYaml) validateDestinationAllowed(allowedDestinations []projectDestination) error {
        appDestination := a.Spec.Destination
        namespaceToCheck := appDestination.Namespace
        
        if namespaceToCheck == "" {
            return fmt.Errorf("application `%s` has no destination namespace specified", a.Metadata.Name)
        }
        
        for _, allowedDest := range allowedDestinations {
            if matchesWildcard(allowedDest.Namespace, namespaceToCheck) {
                log.Printf("Destination validation passed: namespace `%s` is allowed for Application `%s`", namespaceToCheck, a.Metadata.Name)
                return nil  // <-- Missing server validation!
            }
        }
        // ...
    }

Problem: The function ONLY validates the namespace but completely ignores the 
server field. This is a security issue! An application could target a completely 
different cluster server as long as the namespace name matches.

Fix: Add server validation logic:
    for _, allowedDest := range allowedDestinations {
        serverMatches := (allowedDest.Server == appDestination.Server) || 
                        (allowedDest.Name != "" && allowedDest.Name == appDestination.Name)
        namespaceMatches := matchesWildcard(allowedDest.Namespace, namespaceToCheck)
        
        if serverMatches && namespaceMatches {
            return nil
        }
    }


3. REGEX PATTERN ERROR IN validateAppName() (Line 134)
-------------------------------------------------------
Location: main.go, line 134

Current Code:
    re := regexp.MustCompile(`^[a-z0-9]+[a-z0-9\.-]+[a-z0-9]`)

Problems:
  a) Missing $ anchor at the end - only validates the START of the string
  b) Pattern doesn't handle single or two-character names correctly
  c) Allows dots (.) which may not be desired for all use cases

Current behavior: "test-name-UPPERCASE-continuation" would pass validation
because the regex only matches the beginning "test-name" part.

Fix for DNS-compliant names (RFC 1123):
    re := regexp.MustCompile(`^[a-z0-9]([a-z0-9-]*[a-z0-9])?$`)

This ensures:
  - Starts with alphanumeric
  - Can contain hyphens in the middle
  - Ends with alphanumeric
  - Handles single-character names
  - Validates the ENTIRE string (with $ anchor)


4. INCORRECT fmt.Errorf USAGE (Lines 154, 371)
-----------------------------------------------
Location: main.go, lines 154 and 371

Current Code:
    return fmt.Errorf(string(output), err)

Problem: This is incorrect usage of fmt.Errorf. The first argument should be 
a format string, not arbitrary output. If output contains format specifiers 
like %s or %v, this will cause runtime panics or incorrect error messages.

Fix:
    return fmt.Errorf("%s: %v", string(output), err)

Or better yet, use fmt.Errorf with %w for error wrapping (Go 1.13+):
    return fmt.Errorf("command failed: %s: %w", string(output), err)


5. INCOMPLETE DESTINATION VALIDATION LOGIC
-------------------------------------------
Location: validateDestinationAllowed() function

Problem: ArgoCD allows destinations to be specified by either 'name' OR 'server',
but the validation doesn't properly handle both cases when checking against 
allowed destinations from the project. The current implementation attempts to 
get the server but doesn't validate it against the allowed list.

The function should check both:
  - If app specifies server, match against allowed destination servers
  - If app specifies name, match against allowed destination names
  - Ensure BOTH server/name AND namespace match an allowed destination


IMPACT ASSESSMENT:
==================

Issue #1 (CRITICAL): Will cause incorrect validation results, potentially 
                     blocking valid deployments or allowing invalid ones.

Issue #2 (HIGH): Security vulnerability - applications could be deployed to 
                 unintended clusters.

Issue #3 (MEDIUM): App name validation is partially broken, may allow 
                   non-compliant names.

Issue #4 (LOW): Could cause runtime errors or confusing error messages.

Issue #5 (MEDIUM): Incomplete security validation for multi-cluster setups.


6. INEFFICIENT BUILD PROCESS - BUILDS FROM SOURCE EVERY RUN
------------------------------------------------------------
Location: Dockerfile

Current Approach:
    FROM golang:alpine as build
    WORKDIR $GOPATH/src/
    ADD . .
    RUN apk update && apk add --no-cache git
    RUN go get -d -v \
      && go build -o /go/bin/argocdApplicationLinter

Problem: The action builds the entire Docker container FROM SOURCE on EVERY 
single execution. This means:

  - Every PR that triggers this linter waits for:
    * Docker image build
    * Go dependencies download (go get -d -v)
    * Full compilation of the Go binary
    * Multi-stage Docker build

  - This adds significant latency to CI/CD pipelines (2-5+ minutes per run)
  - Wastes GitHub Actions minutes
  - Increases costs
  - Slows down developer feedback loops

Better Approaches:

Option 1: Pre-built Container Image (RECOMMENDED)
  - Build and publish the Docker image to a container registry (GitHub Container
    Registry, Docker Hub, etc.)
  - Tag with version numbers
  - Reference the pre-built image in action.yml:
    
    runs:
      using: 'docker'
      image: 'docker://ghcr.io/bandwidth/argocd-linter:v1.2.3'

  - Build new images only when the linter code changes
  - Reduces run time from minutes to seconds

Option 2: Composite Action with Pre-built Binary
  - Publish compiled binaries as GitHub releases
  - Download the binary in a composite action
  - Much faster than building from source

Option 3: Cache Docker Layers
  - If building from source is required, use proper layer caching
  - Separate dependency installation from source code
  - Use GitHub Actions Docker layer caching

Impact: CRITICAL for CI/CD performance and cost


RECOMMENDED ACTIONS:
====================

1. Fix the inverted logic in environment detection immediately (Issue #1)
2. Add proper server validation to validateDestinationAllowed() (Issue #2)
3. Fix the regex pattern and add comprehensive test cases (Issue #3)
4. Correct fmt.Errorf usage throughout the codebase (Issue #4)
5. Review and strengthen the overall destination validation logic (Issue #5)
6. MOVE TO PRE-BUILT DOCKER IMAGES IMMEDIATELY (Issue #6) - huge performance win
7. Add integration tests that cover all these edge cases
8. Consider adding linting tools (golangci-lint) to catch these issues

